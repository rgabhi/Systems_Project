// src/main_integrated.cpp

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include "system_manager.h"
#include "compiler.h"

// Wrap declarations for C-language functions defined in .c files
extern "C" {
    #include "shell/apsh_module.h" 
    #include "parser/ast.h"
    
    // Explicitly declare functions defined in C files (like parser.tab.c)
    // so the C++ compiler doesn't "mangle" the names.
    int _Z7yyparsev();       // Generated by Bison in parser.tab.c
    extern FILE* yyin;   // Used by Flex
    extern ASTNode* root; // Global root defined in parser.y
    
    // Also include other Lab 1 functions if they cause errors
    void add_prompt();
    char **tokenize_input(char *line);
    int apsh_execute_with_and(char **args, LRUCache *cache);
    int apsh_export(char **args); 
}

SystemManager sys;

// --- SystemManager Implementation ---
int SystemManager::submit_program(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (!file) { perror("Submit failed"); return -1; }
    
    yyin = file;
    if (_Z7yyparsev() != 0) { 
        std::cerr << "Parsing failed\n"; 
        fclose(file); 
        return -1; 
    }
    fclose(file);

    // Compile
    std::string asmSource = compiler.compile(root);
    
    // Assemble
    uint8_t bytecode[CODE_SIZE];
    memset(bytecode, 0, CODE_SIZE);
    
    // PASS 1
    std::map<std::string, int> labels;
    int pc = 0;
    std::stringstream ss1(asmSource);
    std::string line;
    while(std::getline(ss1, line)) {
        char lineBuf[128];
        strcpy(lineBuf, line.c_str());
        pc = parse_labels(lineBuf, pc, labels);
    }
    
    // PASS 2
    pc = 0;
    std::stringstream ss2(asmSource);
    while(std::getline(ss2, line)) {
        char lineBuf[128];
        strcpy(lineBuf, line.c_str());
        pc = assemble_line(lineBuf, bytecode, pc, labels);
    }

    // Create Process
    VM* newVM = new VM(bytecode);
    Process* p = new Process{nextPid++, newVM, filename, false, false};
    processTable[p->pid] = p;
    
    return p->pid;
}

void SystemManager::run_program(int pid) {
    if (processTable.find(pid) == processTable.end()) {
        std::cout << "PID not found.\n";
        return;
    }
    Process* p = processTable[pid];
    p->is_running = true;
    p->vm->run(); 
    p->is_running = false;
}

void SystemManager::debug_program(int pid) {
     if (processTable.find(pid) == processTable.end()) return;
     Process* p = processTable[pid];
     VM* vm = p->vm;
     
     std::string cmd;
     std::cout << "Entering Debug Mode for PID " << pid << "\n";
     
     while(true) {
         std::cout << "(debug) ";
         if (!std::getline(std::cin, cmd)) break;
         
         if (cmd == "step") {
             vm->step(); 
             std::cout << "PC: " << (int)(vm->inst_ptr - vm->program) 
                       << " | Inst Count: " << vm->getInstructionCnt() << "\n";
         }
         else if (cmd == "memstat") {
             // Lab 5 Integration
             int reclaimed = gc(vm); 
             int free_slots = count_free_list(vm);
             std::cout << "[GC] Reclaimed: " << reclaimed << " objects.\n";
             std::cout << "[Heap] Free slots: " << free_slots << "/" << HEAP_SIZE << "\n";
         }
         else if (cmd == "continue") {
             vm->run();
             break;
         }
         else if (cmd == "quit") {
             break;
         }
     }
}

// --- Main Entry Point ---
int main() {
    char *line = NULL;
    size_t len = 0;
    ssize_t read;
    
    // Initialize Lab 1 History Cache
    LRUCache *lru_cache = lru_create(20);

    printf("\033[1;32m        INTEGRATED SYSTEM (Labs 1-5)\033[0m\n\n");

    while (1) {
        add_prompt(); // From Lab 1

        read = getline(&line, &len, stdin);
        if (read == -1) break; // EOF

        // Add to history (Lab 1)
        lru_put(lru_cache, line);

        // Tokenize using Lab 1 logic (handles quotes etc)
        char **args = tokenize_input(line);

        if (args[0] == NULL) {
            free(args);
            continue;
        }

        // Integrated Commands
        if (strcmp(args[0], "submit") == 0) {
            if (args[1]) {
                int pid = sys.submit_program(args[1]);
                printf("Program submitted. PID = %d\n", pid);
            } else {
                printf("Usage: submit <filename>\n");
            }
        }
        else if (strcmp(args[0], "run") == 0) {
            if (args[1]) sys.run_program(atoi(args[1]));
            else printf("Usage: run <pid>\n");
        }
        else if (strcmp(args[0], "debug") == 0) {
             if (args[1]) sys.debug_program(atoi(args[1]));
             else printf("Usage: debug <pid>\n");
        }
        else {
             // Fallback to Lab 1 System Commands
             apsh_execute_with_and(args, lru_cache);
        }
        
        free(args);
    }
    
    lru_free(lru_cache);
    free(line);
    return 0;
}